# 单机数据库

## 数据库存储结构

### 服务器结构

```c
 typedef struct redisServer{
      // 服务器中所有的数据库
      redisDb *db;
      // 数据库数量
      int dbnum;
	}redisServer;
```

数据库数量默认为16，通过databases参数配置。

### 切换数据库
- SELECT [INDEX] 进行切换
```c
typedef	struct redisClient{
      // 记录客户端当前正在使用的数据库
      redisDb *db;
	}redisClient
```

### 数据库键空间
```c
typedef struct redisDb{
  // 数据库键空间，保存数据库中所有的键值对
  dict *dict;
}redisDb;
```
- 存储的键为字符串对象，而值则是指向各种对象的引用
- 增删改查的操作及FLUSHDB、RANDOMKEY、DBSIZE、EXISTS等命令
- 维护功能：
  1. 更新服务器的键命中次数和错失(miss)次数：keyspace_hit和keyspace_misses，通过INFO STATS查看；
  2. 更新键的LRU时间；
  3. 读取键的时候发现该键已过期，就会先删除该键，在执行剩余操作；
  4. 该键被client WATCH，则服务器修改够标记为脏的(dirty)，用于通知事务程序该键已被修改；
  5. 每次修改键则脏键计数器加一，该计数器用于触发持久化和复制等操作；
  6. 如果配置了数据库通知功能，在键修改后，将配置发送到相应的数据库通知；

### 设置键的过期时间
- 过期时间设置
  Redis 有四个不同的命令可以用于设置键的生存时间(键可以存在多久)或过期时间(键什么时候会被删除) :
- EXPlRE <key> <ttl> 命令用于将键key 的生存时间设置为ttl 秒。
- PEXPIRE <key> <ttl> 命令用于将键key 的生存时间设置为ttl 毫秒。
- EXPIREAT <key> < timestamp> 命令用于将键key 的过期时间设置为timestamp所指定的秒数时间戳。
- PEXPIREAT <key> < timestamp > 命令用于将键key 的过期时间设置为timestamp所指定的毫秒数时间戳。
  底层均通过PEXPIREAT进行转换实现。
  TTL和PTTL分别返回妙级和毫秒级的生存时间。
  PESIST用于消除键的过期时间。

- 过期时间保存
```c
	typedef struct redisDb{
      
      // 过期时间词典,键值为该键生存时间的UNIX时间戳
      dict *expires
	}redisDb;
```

- 过期键的删除策略
  - 定时删除：设置键的过期时间的同时，创建一个定时器（timer），让定时器在键过期时间来临时，立刻执行对键的删除操作。
    - 优势：内存友好。过期键能够及时释放内存。
    - 劣势：CPU不友好。大量过期键需要删除时，占用一部分CPU时间，影响服务器的响应时间和吞吐量。
  - 惰性删除：放任键过期不管，每次从键空间获取键时，都检查该键是否过期，过期则删除，否则返回该键。
    - 优势：CPU友好，只花费最必要的CPU时间。
    - 劣势：内存不友好，过期键不被访问则其占有的内存长期得不到释放。
  - 定期删除：每隔一段时间执行一次删除过期键操作，并限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。难点在于确定时长和频率。 

- Redis的过期键删除策略：
  结合惰性删除策略和定期删除策略实现，其中定期删除策略会在规定时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。

- AOF、RDB和复制功能对过期键的处理
  - RDB不会保存，主服务器模式下不会载入，从服务器模式载入，但会被主服务器覆盖。
  - 被删除后，AOF添加DEL命令，来显式地记录该键已被删除。AOF重写无影响。
  - 复制模式，过期键删除由主服务器控制，从服务器执行客户端读命令时碰到过期键也不会删除，而继续正常处理，直到街道主服务器的DEL命令。

### 数据库通知
- 让客户端订阅指定频道或模式来获知数据库中键的变化，以及数据库中命令的执行情况。
  - “某键执行了什么命令“的通知为键空间通知（key-space notification）。
    命令：SUBSCRIBE __keyspace@0__:[key]
  - “某个命令被什么键执行了”的通知为键事件通知（key-event notification）。
    命令：SUBSCRIBE __keyevent@0__:[event]
- 配置：
  - 可以通过修改 redis.conf 文件， 或者直接使用 CONFIG SET notify-keyspace-events [OPTIONS] 命令来开启或关闭键空间通知功能。参数为字符组合，主要参数为：
     - K：键空间通知，所有通知以 __keyspace@<db>__ 为前缀；
       - E：键事件通知，所有通知以 __keyevent@<db>__ 为前缀；
       - l：列表命令的通知
       - A：参数 g$lshzxe 的别名；
       - 其余参数参考redis.conf文件。
  - 输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。例如：Kl为订阅列表的键空间通知。AKE 表示发送所有类型的通知。

## RDB持久化

### RDB文件

RDB持久化是通过快照的方式将redis数据库数据存储为经过压缩的二进制文件。

- 存储配置（redis.conf）：
  - dbfilename：存储文件名称。
  - dir：存储文件路径。

- RDB文件的创建：
  - SAVE：阻塞服务器进程，直到创建完毕，期间不能处理任何命令请求。
  - BGSAVE：创建子进程保存，不阻塞服务器进程，可以正常处理请求。但期间SAVE、BGSAVE命令会被拒绝，主要为了防止父进程和子进程产生竞争条件。同时用于重写AOF的BGREWRITEAOF和BGSAVE也不能同时执行，主要是防止子进程同时执行大量磁盘写入操作影响正常服务性能。
  - 通过SHUTDOWN命令关闭服务器或接收到标准TERM信号时，会执行SAVE命令，执行完毕后关闭服务器。
  - 另一个Redis Server链接到主服务器时，若其发送SYNC命令进行复制操作，如果主服务器目前在执行BGSAVE操作，或者主服务器并非刚刚执行完BGSAVE操作，则主服务器执行一次BGSVAE。


- BGSAVE的执行流程：
  1. Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）。
  2. 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中
    的临时文件。
  3. 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完
    成。

  *在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。*

- RDB文件的载入：
	- 在服务器启动的时候，检测到RDB文件，就会自动载入RDB文件。
	- 在AOF文件开启时，优先使用AOF文件载入数据。
 	
    
- **大数据量问题：Redis内存占用量达到几十GB，并且剩余内存不多的情况下，BGSAVE创建子进程可能会导致服务停顿。时间可能长达十几分钟至几十分钟，这个问题在数据可靠性允许的情况下可以关闭自动保存，而改为手动执行SAVE或BGSAVE命令在服务相对空闲时间执行。SAVE由于不需要创建子进程，而且执行过程中没有子进程争抢资源，所以SAVE创建快照的速度比BGSAVE更快。**
 	 

### 自动间隔保存

1. 配置条件

进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是Redis默认采用的持久化方式，在配置文件redis.conf中通过save参数指定快照条件，可以存在多个条件，条件之间是“或”的关系。redis.conf已经预置了3个条件：
- save 900 1 （在900秒之内，数据库至少执行了1次修改）
- save 300 10
- save 60 10000

2. 实现原理

```c
	struct redisServer{
      
      // 记录了保存条件的数组
      struct saveparam *saveparams;
      
      // 上一次快照之后对数据库进行了多少次修改
      long long dirty;
      
      // 上一次成功快照的UNIX时间戳
      time_t lastsave;
	}
	
	struct saveparam{
      
      // 秒数
      time_t seconds;
      
      // 修改数
      int changes;
	}
	
```
- saveparms数组记录了执行快照的条件。
- 快照条件的检测是由服务器周期性操作函数serverCron默认每个100毫秒执行一次。

### 数据丢失问题

**通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。**这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。**如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。**


### RDB文件结构

- 主体格式：
	|REDIS|db_version|databases|EOF|check_sum|
- databases（数据库）部分：
	|database 0|database 1|……
- 数据库格式：
	|SELECTDB|db_number|key_value_pairs|
	- db_number保存着数据库号码
	- key_value_pairs保存着所有键值对数据
- 键值对部分：
	- 无过期时间：|TYPE|key|value|
	- 有过期时间：|EXPIRETIME_MS|ms|TYPE|key|value|（ms为以毫秒为单位的UNIX时间戳）
- 值（Value）存储格式：
	- 字符串对象（REDIS_RDB_TYPE_STRING）
		- 整型类型（REDIS_ENCODING_INT）：|ENCODING|integer|（ENCODING类型包括REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16、REDIS_RDB_ENC_INT32）
		- 字符串类型（REDIS_ENCODING_RAW）：
			- 小于等于20字节无压缩保存：|len|String|（len为字符串长度）
			- 超过20个字节通过LZF算法压缩保存：|REDIS_RDB_ENC_LZF|compress_len|origin_len|compressed_string|
	- 列表对象（REDIS_RDB_TYPE_LIST）
		- 链表类型（REDIS_ENCODING_LINKEDLIST）：|list_length|item1|item2|...|itemN|
	- 集合对象（REDIS_RDB_TYPE_SET）
		- 哈希表类型（REDIS_ENCODING_HT）：|set_size|elem1|elem2|...|elemN|
	- 哈希表对象（REDIS_RDB_TYPE_HASH）
		- 哈希表类型（REDIS_ENCODING_HT）：|hash_size|key1|value1|...|keyN|valueN|
	- 有序集合对象（REDIS_RDB_TYPE_ZSET）
		- 跳跃表类型（REDIS_ENCODING_SKIPLIST）：|sorted_set_size|member1|score1|member2|score2|...|memberN|scoreN|
	- 整型集合对象（REDIS_RDB_TYPE_SET_INTSET）
		- 转化为字符串对象存储。
	- 压缩列表对象（REDIS_RDB_TYPE_[LIST|HASH|ZSET]_SKIPLIST）
		- 将压缩列表转换为字符串对象存储。

		









